#!/usr/cti/apps/CSPbase/Perl/bin/perl

##############################################################################
# Template Script.
# for use at solaris replace the first line with:
# #!/usr/local/bin/perl
#
# for use before CSPBase Installation (at Linux) change the first line to:
# #!/usr/bin/perl
##############################################################################

use strict;
use XML::LibXML;
#########################################################
#  Global variables
#########################################################

my $G_ErrorCounter=0;
my %G_CLIParams=(  LogFile  => "-,/tmp/WHC_SiteBookSupport.log" );
my @G_FileHandle=();

sub WrLog 
###############################################################################
#
# Input:	@Lines
#	@Lines - List of Lines to write to Log
#
# Return:	nothing
#
# Description: Write to log files ($G_CLIParams{LogFile}) if the file is close
#		it opens the file for write.
#
###############################################################################
{
    my @Lines=@_;
    if ( $#G_FileHandle < 0 )
    {
    	my @FilesList=split(/,/,$G_CLIParams{LogFile});
    	my $Counter=1;
    	foreach my $fn (@FilesList)
    	{
    		push (@G_FileHandle,eval("\\*LOGFILE$Counter"));
    		open $G_FileHandle[-1],">> $fn" or die "Fatal Error !  Fail to open LogFile \"$fn\"" ;
    		$Counter++;
    	}
    	PrnTitle("Start $0","at " . `date`);
    }
    foreach (@Lines)
    {
    	chomp $_;
    	foreach my $fh (@G_FileHandle)
    	{
    	    print $fh "$_\n";
    	}
    }
}

sub PrnTitle
###############################################################################
#
# Input:	$Text1[$Text2 ...]
#		The text to print at the Title.
#
# Return:	Nothing
#
# Description: print Title to the LogFile.
#
###############################################################################
{
   my $TSize=70;
   my $Ch_Title="*";
   my $Border=$Ch_Title x ($TSize + 4);
   
   WrLog($Border);
   foreach (@_)
   {
       chomp $_;
       $_ =~ s/\t/  /g ;
       WrLog(sprintf ("$Ch_Title %-${TSize}s $Ch_Title\n",$_));
   }
   WrLog($Border);
}

sub EndProg
###############################################################################
#
# Input:	ExitCode[,@Lines]
#		ExitCode - integer. The exit code the program will exit.
#		@Lines - Text to print to the Log file.
#
# Return:	Nothing
#
# Description: Exit the program and close the log file.
#
###############################################################################
{
     my $ExitCode=shift;
     WrLog(@_);
     foreach my $fh (@G_FileHandle)
     {
     	defined fileno($fh) or next ;
     	close $fh ;
     }
     exit $ExitCode;
}

sub RunCmds # @list of commands
###############################################################################
#
# Input:	command1[,comand2,command3 ....]
#	    	List of command to execute.
#
# Return:	exit code of ALL commands (O.K should be 0).
#
# Description:  Execute commands. it would NOT stop by failure of single command.
#		but it will return the amount of failure ( if there were ...)
#
###############################################################################
{
    my ($Err,$Cmd);
    my $ErrCounter=0;
    my @Commands=@_;
    my @OutPut=();
    
    foreach $Cmd (@Commands)
    {
	WrLog("Execute: $Cmd");
	@OutPut=`$Cmd 2>&1`;
	$Err=$?;
	foreach (@OutPut)
	{
	    WrLog("\t$_");
	}
    	$ErrCounter += $Err;
    	if ( $Err )
    	{
    		WrLog("- Error Last Command \"$Cmd\" Finish with exit code $Err");
    	}
    }
    return $ErrCounter != 0 ? 1 : 0;
}

sub ReadFile
###############################################################################
#
# Input:	$FileName
#
# Return:	@Lines - Content of the file
#
# Description: Read the file and return the array @lines - each line is 
#		a record at the array. if an error occurred @lines will be
#		empty. and G_ErrorCounter will be increment
#
###############################################################################
{
   my $File=shift;
   my $Err=0;
   my $Line;
   my @Result=();
   unless ( -e $File )
   {
   	WrLog("ERROR - File $File does not exist!");
   	$G_ErrorCounter++;
   	return;
   }
   WrLog("Reading File $File");
   open INPUT,"< $File";
   $Err=$?;
   while ( <INPUT> )
   {
   	$Err += $?;
   	$Line=$_;
   	chomp $Line;
   	push(@Result,$Line);
   }
   close INPUT ;
   $Err += $?;
   if ( $Err )
   {
   	WrLog("ERROR - An error occured during reading the file $File.");
   	$G_ErrorCounter++;
   	return ;
   }
   return @Result;
}

sub ParseUnitGroup
###############################################################################
#
# Input: Systemname
#
# Return: Hash Table which contains UnitHostName => UnitIP of all NDU-WHC units that appears in the UnitGroup.xml that is generated by the SWIM Utility
#
# Description: The function recieves the SysteName and scans all NDU-WHC units that appears in the UnitGroup.xml that is generated by the SWUIM Utility
#
###############################################################################
{
    my $SystemName=shift;
    my $SwimUnitGroupFileName=$SystemName . "SiteBookUnitGroup.xml";
    my $UnitFile="/tmp/$SwimUnitGroupFileName";
    unless ( -e $UnitFile )
    {
        WrLog("Error - could not find file $UnitFile");
        $G_ErrorCounter++;
        return ;
    }
    my (%UnitGroupList,$UnitHostName,$UnitIP);
    my $UnitGroupXml=XML::LibXML->new()->parse_file($UnitFile);
    my @UnitXml=$UnitGroupXml->findnodes("//UnitGroup/Physical[\@GroupName=\"NDU-WHC_Group\"]");
    foreach my $UnitInstace ($UnitXml[0]->getChildrenByLocalName("UnitInstance") )
    {
        $UnitIP=$UnitInstace->getAttribute("DataIp");
        $UnitHostName=$UnitInstace->getAttribute("Hostname");
        $UnitGroupList{$UnitIP}=$UnitHostName;
    }
    return %UnitGroupList;
}

sub UnitsVerification
###############################################################################
#
# Input:
#
# Return:
#
# Description:
#
###############################################################################
{
    my $UnitGroupFile=shift;
    my $SystemName=shift;
    my (%UnitGroupIpList , %SwimUnitGroupIpList);
    my ($UnitGroupHostName , $SwimUnitGroupHostName , $UnitHostname , $UnitIP);

    my $XMLObj=XML::LibXML->new();
    my $RootObj=$XMLObj->parse_file($UnitGroupFile)->documentElement();

	#### Creating Hash Table of WHC units which appears in the UnitGroup in the following format : UnitIP -> UnitHostName
    my @UnitList=$RootObj->findnodes("//Physical[\@GroupName=\"NDU-WHC_Group\"]/UnitInstance");
    foreach my $UnitInst (@UnitList)
    {
        $UnitHostname=$UnitInst->getAttribute("Hostname");
        $UnitIP=$UnitInst->getAttribute("DataIp");
        $UnitGroupIpList{$UnitIP}=$UnitHostname;
    }

    #### Printing WHC units that appear in the UnitGroup
	WrLog ("WHC units as appears in UnitGroup :\n");
    foreach my $key (keys %UnitGroupIpList)
    {
        WrLog (sprintf ("Unit IP = %-15s Unit Hostname = %-35s\n",$key,$UnitGroupIpList{$key}));
    }

	#### Creating Hash Table of NDU-WHC units which appears in the SWIM UnitGroup in the following format : UnitIP -> UnitHostName
    %SwimUnitGroupIpList=ParseUnitGroup($SystemName);

    #### Comparing NDU-WHC Units that appears in the Hash Table generated above
    foreach my $UnitIPIter ( keys %SwimUnitGroupIpList )
    {
        WrLog ("\nFollowing is the comparison of Unit $UnitIP between UnitGroup that is generated by SWIM Utility and UnitGroup generated by the SCDB:");
        #### Verifying that SWIM UnitGroup IP appears in the Hash Table created (containing the NDU-WHC units that appears in SCDB UnitGroup)
        if (exists $UnitGroupIpList{$UnitIPIter})
        {
            WrLog ("Unit $UnitIP appears both in the SWIM UnitGroup List and in the SCDB UnitGroup");
            $UnitGroupHostName=$UnitGroupIpList{$UnitIPIter};
            $SwimUnitGroupHostName=$SwimUnitGroupIpList{$UnitIPIter};
            WrLog ("Hostname (SWIM UnitGroup) = $SwimUnitGroupHostName , \tHostname (SCDB UnitGroup) = $UnitGroupHostName");
            #### Verifying that Hostname in UnitGroup has the same Prefix of the one in SWIM UnitGroup List
            if ( $UnitGroupHostName=~ /^$SwimUnitGroupHostName(\.|$)/ )
            {
                WrLog ("Unit $UnitIPIter appears with the same Hostname both in SWIM UnitGroup and SCDB UnitGroup\n");
                next;
            }
            else
            {
                WrLog ("WARN - Unit $UnitIPIter appears in the both UnitGroups ,","WARN - But its Hostname is different between SWIM UnitGroup = $SwimUnitGroupHostName , and SCDB UnitGroup = $UnitGroupHostName",
                       "WARN - The script will continue and SiteBook will use the Hostname as appears in SCDB UnitGroup = $UnitGroupHostName");
                next;
            }
        }
        else
        {
            EndProg (1,"ERROR - Unit $UnitIPIter does not appear in the SCDB UnitGroup , please correct it using relevant SCDB Procedure prior to running the kit (script) again");
        }
    }
    WrLog ("All Units appears both in SWIM UnitGroup and SCDB UnitGroup , continue to SiteBook procedures...");
}


############################################################################################
#
#   					M A I N
#
############################################################################################

### Verify System Name via SystemList file  ###
my $SystemListFile="/usr/cti/apps/sitebook/catalinaBase/webapps/sitebook/config/SystemList.xml";
WrLog ("Verifying that SystemList file is located in SiteBook Configuration folder");
if (! -f $SystemListFile)
{
	EndProg (1,"SystemList.xml file does not exist in SiteBook Folder , please fix it using the correct CLI before Re-running the script");
}
WrLog ("SystemList.xml file is located in SiteBook Configuration folder");
my $SystemNameSWIM=shift;
my $root=XML::LibXML->new()->parse_file($SystemListFile);
my $xmlElemt=$root->getDocumentElement;
my $SystemName=$xmlElemt->find("//SystemList/SystemRoot[\@SystemName=\"$SystemNameSWIM\"]/\@SystemName");
if (!$SystemName)
{ 
	EndProg (1,"ERROR - The System Name that was entered does not appear in the SystemList.xml");
}
WrLog ("The System Name that you are working with does not appear in SystemList.xml file");
### Verify UnitGroup file exists in SystemName folder ###
WrLog ("Verifying that UnitGroup file is located in SiteBook System Name=$SystemName folder");
my $UnitGroupFile="/usr/cti/apps/sitebook/catalinaBase/webapps/sitebook/config/$SystemName/UnitGroup.xml";
unless ( -f  $UnitGroupFile )
{
	EndProg(1,"ERROR - UnitGroup file does not exists \"$UnitGroupFile\"");
}
WrLog ("UnitGroup.xml is located in System Name=$SystemName folder");
UnitsVerification($UnitGroupFile,$SystemName);

###  Verify SiteBook is online   ####
WrLog ("Verifying that SiteBook is online");
if ( RunCmds("/usr/cti/apps/sitebook/catalinaBase/webapps/sitebook/SiteBook_CLI.sh") )
{
	EndProg(1,"Fatal - SiteBook is down");
}

### Updating SiteBook Topology and MetaData files ##### 
WrLog ("Running SiteBook Reflect Topology");
$G_ErrorCounter += RunCmds("/usr/cti/apps/sitebook/catalinaBase/webapps/sitebook/SiteBook_CLI.sh reflect_topology");

unless ( $G_ErrorCounter )
{
	WrLog ("Running SiteBook Rebuild MetaData");
	$G_ErrorCounter += RunCmds("/usr/cti/apps/sitebook/catalinaBase/webapps/sitebook/SiteBook_CLI.sh rebuild_metadata" );
}
###########################################################################################################

my $ErrMessage= $G_ErrorCounter ? "Finish with ERRORS see Log File $G_CLIParams{LogFile}" :
		"Finish Successfully :-)";
EndProg($G_ErrorCounter,$ErrMessage);